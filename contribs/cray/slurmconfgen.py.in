#!/usr/bin/python
#
# (c) Copyright 2013 Cray Inc.  All Rights Reserved.
#
# slurmconfgen.py
#
# A script to generate a slurm configuration file automatically. Should be
# run from a service node on the system to be configured. With no arguments,
# writes configuration to stdout. 
#
# With --reconfigure argument, this command must be run as root on the boot 
# node. It backs up slurm.conf to slurm.conf.<timestamp>, overwrites slurm.conf
# with the new configuration, and updates Slurm with the new configuration.

import subprocess, os, shutil, sys, datetime, tempfile, stat, re, time

#######################################
# sdb_query
#######################################
def sdb_query(query):
	""" Query the SDB. Returns the results, space separated. """
	# Call isql
	isql = subprocess.Popen(["isql", "XTAdmin", "-b", "-v", "-x0x20"], 
		stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
	# Execute the query
	(out, err) = isql.communicate(query)
	if len(err) > 0:
		raise Exception(err)
	
	return out

#######################################
# get_nodes
#######################################
def get_nodes():
	""" Get the nodes from the SDB. Returns a list of tuples with entries for
		nodeid, memory, cores, sockets, compute units, gpu """
    
	# Query the SDB for the info
	out = sdb_query("SELECT nodeid,availmem,numcores,sockets,cu,avail \
		FROM attributes LEFT JOIN processor ON nodeid=processor_id \
			LEFT JOIN gpus ON nodeid=node_id \
		WHERE processor_type='compute' ORDER BY nodeid;")
    
	# Now out should contain all the compute node information
	nodes = []
	for line in out.splitlines():
		fields = line.split()
		if len(fields) == 5:
			# This doesn't have a GPU
			nodes.append(tuple([int(x) for x in fields]) + (0,))
		elif len(fields) == 6:
			# This does have a GPU
			nodes.append(tuple([int(x) for x in fields]))
		else:
			raise Exception("Couldn't parse line " + line)
	
	return nodes

#######################################
# split_nodes
#######################################
"""
Test data from opal-p2:
[(24,32768,40,2,20,0), (25,32768,40,2,20,0), (26,32768,40,2,20,0), 
 (27,32768,40,2,20,0), (32,32768,16,1,8,1), (33,32768,16,1,8,1),
 (34,32768,16,1,8,1), (35,32768,16,1,8,1), (48,65536,32,2,16,0),
 (49,65536,32,2,16,0), (50,65536,32,2,16,0), (51,65536,32,2,16,0)]
"""
def split_nodes(nodelist):
	""" Given a list of nodes as returned by get_nodes, returns a tuple of
		equivalence class representative list, equivalence class nid list. """
	
	class_reps = []
	class_nodes = []
	
	for node in nodelist:
		nodeid, memory, cores, sockets, cu, gpu = node
		
		# Check if this matches an existing representative
		i = 0
		match = False
		for rep in class_reps:
			rnodeid, rmemory, rcores, rsockets, rcu, rgpu = rep
			if (memory == rmemory and cores == rcores and sockets == rsockets
				and cu == rcu and gpu == rgpu):
				# We have a match, add to the nodes for this class
				class_nodes[i].append(nodeid)
				match = True
				break
			i += 1
		
		# We didn't find a matching equivalence class, make a new one
		if not match:
			class_reps.append(node)
			class_nodes.append([nodeid])
	
	return class_reps, class_nodes

######################################
# range_str
######################################
def range_str(range_start, range_end, field_width):
	""" Returns a string representation of the given range 
		using the given field width """
	if range_end < range_start:
		raise Exception('Range end before range start')
	elif range_start == range_end:
		return "{0:0{1}d}".format(range_end, field_width)
	elif range_start + 1 == range_end:
		return "{0:0{2}d},{1:0{2}d}".format(range_start, range_end, field_width)
	
	return "{0:0{2}d}-{1:0{2}d}".format(range_start, range_end, field_width)

######################################
# rli_compress
######################################
def rli_compress(nidlist):
	""" Given a list of node ids, rli compress them into a slurm hostlist
	   (ex. list [1,2,3,5] becomes string nid0000[1-3,5]) """
	
	# Determine number of digits in the highest nid number
	numdigits = len(str(max(nidlist)))
	if numdigits > 5:
		raise Exception('Nid number too high')
	
	# Create start of the hostlist
	rli = "nid" + ('0' * (5 - numdigits)) + '['

	range_start = nidlist[0]
	range_end = nidlist[0]
	add_comma = False
	for nid in nidlist:
		# If nid too large, append to rli and start fresh
		if nid > range_end + 1 or nid < range_end:
			rli += ("," if add_comma else "") + range_str(range_start, range_end, numdigits)
			add_comma = True
			range_start = nid
		
		range_end = nid
	
	# Append the last range
	rli += ("," if add_comma else "") + range_str(range_start, range_end, numdigits) + ']'
	
	return rli

#######################################
# format_nodes
#######################################
def format_nodes(class_reps, class_nodes):
	""" Given a list of class representatives and lists of nodes in those
		classes, formats a string in slurm.conf format 
		(ex. NodeName=nid00[024-027] CPUs=40 Sockets=2 CoresPerSocket=10 
		ThreadsPerCore=2 RealMemory=32768) """
	
	i = 0
	nodestr = ""
	for rep in class_reps:
		nodeid, memory, cores, sockets, cu, gpu = rep
		feature = " Feature=gpu" if gpu > 0 else ""
		nodestr += "NodeName={0} CPUs={1:d} Sockets={2:d} CoresPerSocket={3:d} \
 ThreadsPerCore={4:d} RealMemory={5:d}{6:s}\n".format(
 			rli_compress(class_nodes[i]), cores, sockets, cu/sockets, cores/cu, 
 			memory, feature)
 		i += 1
 	
 	return nodestr

#######################################
# cluster_name
#######################################
def cluster_name():
	""" Gets the cluster name from /etc/xthostname """
	
	with open("/etc/xthostname", "r") as xthostname:
		return xthostname.readline().rstrip()

#######################################
# xtopview
#######################################
def xtopview(cmd):
	""" Runs the given command in xtopview -e, retries if xtopview is in use """
	
	while True:
		try:
			subprocess.check_call(["xtopview", "-e", cmd])
		except subprocess.CalledProcessError as e:
			if e.returncode == 208:
				print "xtopview in use, retrying in 10 seconds"
				time.sleep(10)
				continue
			else:
				raise
		break
		
#######################################
# get_control_machine
#######################################
def get_control_machine(f):
	""" Parses the ControlMachine from the given file """
	
	f.seek(0)
	for line in f:
		m = re.match(r"[^#]*ControlMachine=([^#\s]+)", line)
		if m:
			return m.group(1)
	
	raise Exception("Failed to parse ControlMachine from {0}".format(f.name))

#######################################
# main
#######################################
if __name__ == "__main__":
	# Some constant file names
	slurmconf = "@sysconfdir@/slurm.conf"
	slurmconf_bak = (slurmconf + "." 
		+ datetime.datetime.today().strftime('%Y%m%d%H%M%S'))
	opview_dir = "/rr/current"
	slurmconf_opview = "/software/slurm.conf"
	restart_slurm = "/etc/init.d/slurm restart"
	scontrol = "@bindir@/scontrol"
	
	reconfigure = len(sys.argv) > 1 and sys.argv[1] == "--reconfigure"

	# Write to a temporary file for reconfigure
	if reconfigure:		
		outfile = tempfile.NamedTemporaryFile()
		os.chmod(outfile.name, 
			stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)
	else:
		outfile = sys.stdout

	# Set environment variable for isql
	os.environ['ODBCSYSINI']='/etc/opt/cray/sysadm/'
	
	# Get nodes using isql
	nodes = get_nodes()
	
	# Split them into equivalence classes
	class_reps, class_nodes = split_nodes(nodes)

	# Read and format the template
	with open(slurmconf + ".template", "r") as template:
		text = template.read()
		replace = { 
			'{sysconfdir}' : "@sysconfdir@", 
			'{spooldir}' : "/var/spool/slurm",
			'{defmem}' : str(min(node[1] for node in nodes)),
			'{maxmem}' : str(max(node[1] for node in nodes)),
			'{clustername}' : cluster_name(),
			'{computenodes}' : format_nodes(class_reps, class_nodes),
			'{nodelist}' : rli_compress([node[0] for node in nodes]) }
		
		# Using replace is less elegant than using string.format, but avoids
		# KeyErrors if the user removes keys from the template file
		for i, j in replace.iteritems():
			text = text.replace(i, j)
		print >> outfile, text
	
	# Start doing the reconfigure if we made it this far
	if reconfigure:
		print "Wrote new configuration to {0}".format(outfile.name)
	
		# Overwrite boot root slurm.conf
		print "Copying {0} to {1}".format(slurmconf, slurmconf_bak)
		shutil.copy2(slurmconf, slurmconf_bak)
		print "Copying {0} to {1}".format(outfile.name, slurmconf)
		shutil.copy2(outfile.name, slurmconf)
		
		# Overwrite shared root slurm.conf
		print "Copying {0} to {1}".format(outfile.name, opview_dir + slurmconf_opview)
		shutil.copy2(outfile.name, opview_dir + slurmconf_opview)
		print "Copying {0} to {1} in xtopview".format(slurmconf, slurmconf_bak)
		xtopview("cp {0} {1}".format(slurmconf, slurmconf_bak))
		print "Copying {0} to {1} in xtopview".format(slurmconf_opview, slurmconf)
		xtopview("cp {0} {1}".format(slurmconf_opview, slurmconf))
		
		# Reconfigure Slurm
		control_machine = get_control_machine(outfile)
		print "Running {0} on {1}".format(restart_slurm, control_machine)
		subprocess.check_call(["ssh", control_machine, restart_slurm])		
		print "Running {0} reconfigure".format(scontrol)
		subprocess.check_call([scontrol, "reconfigure"])
		
