#!/usr/bin/python
#
# (c) Copyright 2013 Cray Inc.  All Rights Reserved.
#
# slurmconfgen.py
#
# A script to generate a slurm configuration file automatically. Should be
# run from a service node on the system to be configured. Writes a slurm.conf
# file to stdout. Review and place in @sysconfdir@/slurm.conf.

import subprocess, os

#######################################
# sdb_query
#######################################
def sdb_query(query):
	""" Query the SDB. Returns the results, space separated. """
	# Call isql
	isql = subprocess.Popen(["isql", "XTAdmin", "-b", "-v", "-x0x20"], 
		stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
	# Execute the query
	(out, err) = isql.communicate(query)
	if len(err) > 0:
		raise Exception(err)
	
	return out

#######################################
# get_nodes
#######################################
def get_nodes():
	""" Get the nodes from the SDB. Returns a list of tuples with entries for
		nodeid, memory, cores, sockets, compute units, gpu """
    
	# Query the SDB for the info
	out = sdb_query("SELECT nodeid,availmem,numcores,sockets,cu,avail \
		FROM attributes LEFT JOIN processor ON nodeid=processor_id \
			LEFT JOIN gpus ON nodeid=node_id \
		WHERE processor_type='compute' ORDER BY nodeid;")
    
	# Now out should contain all the compute node information
	nodes = []
	for line in out.splitlines():
		fields = line.split()
		if len(fields) == 5:
			# This doesn't have a GPU
			nodes.append(tuple([int(x) for x in fields]) + (0,))
		elif len(fields) == 6:
			# This does have a GPU
			nodes.append(tuple([int(x) for x in fields]))
		else:
			raise Exception("Couldn't parse line " + line)
	
	return nodes

#######################################
# split_nodes
#######################################
"""
Test data from opal-p2:
[(24,32768,40,2,20,0), (25,32768,40,2,20,0), (26,32768,40,2,20,0), 
 (27,32768,40,2,20,0), (32,32768,16,1,8,1), (33,32768,16,1,8,1),
 (34,32768,16,1,8,1), (35,32768,16,1,8,1), (48,65536,32,2,16,0),
 (49,65536,32,2,16,0), (50,65536,32,2,16,0), (51,65536,32,2,16,0)]
"""
def split_nodes(nodelist):
	""" Given a list of nodes as returned by get_nodes, returns a tuple of
		equivalence class representative list, equivalence class nid list. """
	
	class_reps = []
	class_nodes = []
	
	for node in nodelist:
		nodeid, memory, cores, sockets, cu, gpu = node
		
		# Check if this matches an existing representative
		i = 0
		match = False
		for rep in class_reps:
			rnodeid, rmemory, rcores, rsockets, rcu, rgpu = rep
			if (memory == rmemory and cores == rcores and sockets == rsockets
				and cu == rcu and gpu == rgpu):
				# We have a match, add to the nodes for this class
				class_nodes[i].append(nodeid)
				match = True
				break
			i += 1
		
		# We didn't find a matching equivalence class, make a new one
		if not match:
			class_reps.append(node)
			class_nodes.append([nodeid])
	
	return class_reps, class_nodes

######################################
# range_str
######################################
def range_str(range_start, range_end):
	""" Returns a string representation of the given range 
		in slurm hostlist format """
	if range_end < range_start:
		raise Exception('Range end before range start')
	elif range_start == range_end:
		return "nid{0:05d}".format(range_end)
	elif range_start + 1 == range_end:
		return "nid{0:05d},nid{1:05d}".format(range_start, range_end)
	
	return "nid[{0:05d}-{1:05d}]".format(range_start, range_end)

######################################
# rli_compress
######################################
def rli_compress(nidlist):
	""" Given a list of node ids, rli compress them into a slurm hostlist
	   (ex. list [1,2,3,5] becomes string nid[00001-00003],nid00005) """
	
	range_start = nidlist[0]
	range_end = nidlist[0]
	rli = ""
	for nid in nidlist:
		# If nid too large, append to rli and start fresh
		if nid > range_end + 1 or nid < rangeend:
			if len(rli) > 0:
				rli += ','
			rli += range_str(range_start, range_end)
			range_start = nid
		
		range_end = nid
	
	# Append the last range
	if len(rli) > 0:
		rli += ','
	rli += range_str(range_start, range_end)
	
	return rli

#######################################
# format_nodes
#######################################
def format_nodes(class_reps, class_nodes):
	""" Given a list of class representatives and lists of nodes in those
		classes, formats a string in slurm.conf format 
		(ex. NodeName=nid00[024-027] CPUs=40 Sockets=2 CoresPerSocket=10 
		ThreadsPerCore=2 RealMemory=32768) """
	
	i = 0
	nodestr = ""
	for rep in class_reps:
		nodeid, memory, cores, sockets, cu, gpu = rep
		feature = " Feature=gpu" if gpu > 0 else ""
		nodestr += "NodeName={0} CPUs={1:d} Sockets={2:d} CoresPerSocket={3:d} \
 ThreadsPerCore={4:d} RealMemory={5:d}{6:s}\n".format(
 			rli_compress(class_nodes[i]), cores, sockets, cu/sockets, cores/cu, 
 			memory, feature)
 		i += 1
 	
 	return nodestr

#######################################
# cluster_name
#######################################
def cluster_name():
	""" Gets the cluster name from /etc/xthostname """
	
	with open("/etc/xthostname", "r") as xthostname:
		return xthostname.readline().rstrip()

#######################################
# main
#######################################
if __name__ == "__main__":
	# Set environment variable for isql
	os.environ['ODBCSYSINI']='/etc/opt/cray/sysadm/'
	
	# Get nodes using isql
	nodes = get_nodes()
	
	# Split them into equivalence classes
	class_reps, class_nodes = split_nodes(nodes)

	# Read and format the template
	with open("@sysconfdir@/slurm.conf.template", "r") as template:
		print template.read().format(slurmdir="@prefix@",
			spooldir="/var/spool/slurm",
			defmem=min(node[1] for node in nodes),
			maxmem=max(node[1] for node in nodes),
			clustername=cluster_name(),
			computenodes=format_nodes(class_reps, class_nodes),
			nodelist=rli_compress([node[0] for node in nodes]))
